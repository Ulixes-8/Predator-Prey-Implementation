#!/usr/bin/env python3
"""
performance_core.py

Core utilities and configuration for predator-prey simulation performance experiments.
This module contains shared constants, system information utilities, and cleanup functions
used by the performance experiment framework.

Author: s2659865
Date: April 2025
"""

# ── Imports ───────────────────────────────────────────────────────────────────
import os
import sys
import glob
import platform
import psutil
import time
import inspect
from typing import Dict, Any

# ── Directories and Paths ──────────────────────────────────────────────────────
# Base directories
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)
LANDSCAPE_DIR = os.path.join(PROJECT_ROOT, "animals")
RESULTS_DIR = "performance_results"

# Create results directory structure if it doesn't exist
def ensure_results_dirs() -> None:
    """
    Create the directory structure for storing experiment results if it doesn't exist.
    """
    for subdir in ["grid_scaling", "landscape_prop", "cpu_scaling", "full_matrix"]:
        os.makedirs(os.path.join(RESULTS_DIR, subdir), exist_ok=True)

# ── Experiment Configuration ────────────────────────────────────────────────────
# Grid sizes for experiments
GRID_SIZES = [10, 20, 40]  # For most experiments
LARGE_GRID_SIZES = [10, 20, 40, 80, 160]  # For specific grid scaling tests

# Land proportion values
LAND_PROPS = [0.1, 0.2, 0.4, 0.8]
DEFAULT_LAND_PROP = 0.75

# CPU configurations
DEFAULT_GRID = 40
CPU_COUNTS = [4, 8, 16, 32]
DEFAULT_CPU_COUNT = 32

# Repetition for statistical validity
NUM_SEEDS = 3
SEEDS = list(range(1, NUM_SEEDS + 1))

# ── Simulation Module Identification ─────────────────────────────────────────────
def get_experiment_tag() -> str:
    """
    Determine which simulation implementation is being used.
    
    This function dynamically determines the experiment tag based on the 
    imported simulation module (baseline, refactor_1, etc.).
    
    Returns:
        str: The name of the current implementation (e.g., 'BASELINE', 'REFACTOR_1')
    """
    # Must be imported here to avoid circular import
    from baseline import simCommLineIntf
    
    # Extract the module name from the function's module
    return os.path.splitext(os.path.basename(inspect.getfile(simCommLineIntf)))[0].upper()

# ── System Information ───────────────────────────────────────────────────────────
def get_system_info() -> Dict[str, Any]:
    """
    Gather system information for reproducibility of experiments.
    
    Returns:
        Dict[str, Any]: Dictionary containing system specifications
    """
    return {
        "os": f"{platform.system()} {platform.release()}",
        "python_version": platform.python_version(),
        "cpu_model": platform.processor(),
        "max_cpu_count": os.cpu_count(),
        "logical_cpus": psutil.cpu_count(logical=True),
        "physical_cpus": psutil.cpu_count(logical=False),
        "total_memory_gb": round(psutil.virtual_memory().total / (1024**3), 2),
        "platform_full": platform.platform()
    }

def print_system_info() -> None:
    """
    Print system information to the console in a human-readable format.
    """
    info = get_system_info()
    print("\n[SYSTEM INFO]")
    print(f"  OS              : {info['os']}")
    print(f"  Python Version  : {info['python_version']}")
    print(f"  CPU Model       : {info['cpu_model']}")
    print(f"  Max CPU Count   : {info['max_cpu_count']}")
    print(f"  Logical CPUs    : {info['logical_cpus']}")
    print(f"  Physical CPUs   : {info['physical_cpus']}")
    print(f"  Memory (GB)     : {info['total_memory_gb']}")
    print("-" * 50)

# ── Cleanup Utilities ───────────────────────────────────────────────────────────
def cleanup_artifacts() -> None:
    """
    Remove temporary files generated by the simulation.
    
    This includes averages.csv and map_*.ppm files that are created
    during each simulation run.
    """
    if os.path.exists("averages.csv"):
        os.remove("averages.csv")

    for ppm_file in glob.glob("map_*.ppm"):
        try:
            os.remove(ppm_file)
        except Exception as e:
            print(f"[WARNING] Failed to remove {ppm_file}: {e}")

# ── Main Entry Point ───────────────────────────────────────────────────────────
if __name__ == "__main__":
    print("This module is not intended to be run directly.")
    print("Please use performance_experiment.py instead.")
    sys.exit(1)